# media-handling-scripts

This is a collection of Python scripts that I use to manage my music collection.
I'm a bit pedantic about the way I organize everything and these scripts help me
convert file types, set consistent names, apply changes to metadata, etc. 

**NOTE**: Many of these scripts do destructive things. They rename files, delete files, and
modify metadata values. **MAKE SURE** you have a backup of your media before using these.
I make no warranties that these scripts won't delete your entire media collection and possibly
worse. *You've been warned*.

Feel free to take what you need. There are no licenses as these are cobbled together from the 
collective ideas of hundreds of people on StackOverflow and various forums.

**My collection is deliberately lossy**. FLACs are great, but they consume a lot of 
disk space. PLUS, I have noticeable hearing loss, so the extra sonic space is
mostly lost on me. MP3 at 320K bitrate works for my needs, as this library is
being streamed via Navidrome and typically sent to Bluetooth devices. If I were
playing from a dedicated device to a high-end audio system, I'd feel differently.

## Notes

* The code assumes the files are named with a pattern of `genre/artist/album/DD-TTT - title.ext
* Pylance complains about subclasses not being exported by mutagen. Even though it flags this
as an error, it does work. This should be a warning, but Pylance treats it as an error. It's safe
to ignore.
* I should refactor the file scanning code into a separate module, as I use it in nearly every
one of these scripts. Someday...

## The Scripts

### delete-media-tag-value

Searches for strings in the media file metadata and removes the item if found.
This is useful because some uploaders will stick links to their site in the 
comments and elsewhere, which shows up in the media playback apps.

`usage: delete-media-tag-value.py [-h] [-t TERM] [-l LIST] [-c] [--dryrun] input`

You can provide multiple `-t` parameters or put them all in a file and use the `-l` option.

The script is case insensitive by default.

There is a special case for this one if the string is found in TPE1 or TPE2 frame, it will
remove the string from the data, but not delete the entire frame. This is to prevent losing
the artist names. Probably need to extend this to TIT2.

### extract_covers

I did not create this, but this is my modified version of the original. The original is
at https://github.com/derwyddon/bulk_mp3_cover_art_extractor

Pulls the cover for an album from the first file it finds with an APIC record. The original
would generate an image file for every file with an APIC record.

`usage: extract_covers.py [-h] -d DIRECTORY`

### fix-media-file-names

Removes a bunch of extra stuff from file names, usually added by uploaders.

`usage: fix-media-file-names.py [-h] input`

Works on either a single file or a folder of files. Works recursively.

Removes the following

* Anything in \(Parentheses\), \[Brackets\], and \<Angle Brackets\>
* Double spaces
* Trailing spaces
* The words vevo and pmedia

If doing all this results in an empty file name, an attempt is made to just remove
the parens and brackets themselves, not the contents within. If that still results
in an empty file name, then nothing is done.

### fix-playlists

Update playlist files because of file name changes. This probably isn't useful to
anyone else unless they have my version of insanity. I had a bunch of curated
playlists that I've maintained for years. After all the reorganizing and renaming
of files, I needed a way to update the playlists based on new names. It's kind of
a 1-shot script, but entirely over-engineered.

`usage: fix-playlists.py [-h] -p PLAYLIST -l LIST -o OUTPUT [-x PREFIX]`

The playlist is the input .m3u file. The LIST item is a CSV file containing 2 columns.
The first is a key that consists of the album name and the song title, without the
numeric prefix, as such
"'Round About Midnight:Dear Old Stockholm.mp3"
The second item is the new path to the song, relative to the top of my music collection.
"Jazz/Miles Davis/'Round About Midnight/01-006 - Dear Old Stockholm.mp3"

The optional prefix is inserted in the second element, otherwise it's left relative to
the top of the collection.

The LIST file is generated by entering the command `dir /s /b *.mp3 > Scripts/all1.txt` from
a CMD shell or `(dir -r *.mp3).FullName > .\Scripts\all1.txt` in Powershell. Bash is left as
an exercise for the reader.

I modify the list file with the following regex
`^E:\\music\\(.+?)\\(.+?)\\(.+?)\\([0-9][0-9]-[0-9][0-9][0-9]) - (.+?)$`
and replace with
`"$3:$5","$1/$2/$3/$4 - $5"`

### flac-to-mp3

As previously mentioned, my collection is lossy. I don't apologize for converting to MP3 for
my own uses. This script operates recursively to convert to MP3 in the same folder at the
specified bitrate, which is 320k by default. The `-d` flag deletes the FLAC on success.

`usage: flac-to-mp3.py [-h] [-b BITRATE] [-o] [-d] input`

### generate-metadata-list

Generates a CSV file to be used to generate a randomized playlist based on genre, year,
artist, and rating. Gets this information by recursively walking the input path and
finding the relevant ID3 metadata fields in each file.

The reason I generate a CSV file rather than querying the library each time is because I would
rather not process the entire library of 25,000+ songs each time I want to generate a new
playlist.

`usage: generate-metadata-list.py [-h] [-o OUTPUT] [-x EXTRACTPREFIX] [-p PREFIX] [-v] input`

The `-x` parameter will remove the local file system prefix to the music library. This
is necessary for me because I generate this file on Windows, but the music is streamed
by Navidrome on Linux. The `-p` parameter is the replacement Linux path, so a typical invokation
would be
`python generate-metadata-list.py -o ratings-list.txt -x "E:\\Music\\" -p "/mnt/music/Albums" E:\\Music`

The ratings are in the POPM element of the file, which is inserted from MusicBrainz data embedded
in the media files by the Picard tool. Picard assigns the release identifier to the song and 
the `search-mbz-ratings` script queries my local mirror of MusicBrainz to extract the ratings and
embed them with the rest of the metadata.

### generate-random-playlist

Generates a random .m3u playlist based on user specified artist, genre, year, and rating.

`usage: generate-random-playlist.py [-h] -l LIST -o OUTPUT [-p PLAYLIST] [-a ARTIST] [-g GENRE] [-y YEAR] [-r RATING] [-n NUMBER] [--all] [-v]`

Until Navidrome supports ratings-based smart playlists, I use this to generate a playlist of songs
with the specified criteria. 

The LIST file is generated by the previously mentioned script. Each "recording" to use the MusicBrainz
term contains this metadata, which is used by the script to filter and generate a playlist.

    recording = {
        "path":line[0],
        "artist": line[1],
        "title": line[2],
        "genre": line[3],
        "rating": int(line[4]),
        "year": int(line[5]),
        "length": int(line[6])
    }

By default, the script matches the first element it sees. If you want to only match all the criteria, specify the
`--all` paramter. This is likely when you want to mix multiple types of filters, such as *Country Songs from 1978 with
a rating of 150 or higher*.

Specify a minimum rating with `-r value`. Ratings are on a 0-255 scale. This is because the original rating was a 1 byte 
value. They are mapped to a 5 star system by multiplying or dividing by 51. So, 3 stars would be 153. All titles higher
than that value are considered.

You can specify multiple artists, genres, and years by using the `-a`, `-g`, or `-y` flags multiple times. You can specify
a range of years with a dash, such as `-y "1950-1959"`

The result is a .m3u file containing `-n` entries. The order is random and not repeated unless the same song is in multiple
albums (such as a greatest hits) and have ratings to match.

### search-mbz-ratings

Queries a MusicBrainz mirror server to find ratings for songs based on the release ID embedded in the song metadata
by the Picard tool. First, run Picard on the songs and let it match the albums. Then, save and run this script to
embed the POPM values into the media file. 

This may be a feature of Picard, but I could not find it. I asked on the MusicBrainz community forums and nobody suggested
it was already a feature there.

`usage: search-mbz-ratings.py [-h] -s SERVER [-o OUTPUT] [-e EMAIL] [-p PARAMS] [-z] [-v] [-w] input`

The code flags if the user is connecting to musicbrainz.org, but nothing prevents anyone from removing
this line in their own fork. Please be kind to their servers.

The `-s` element needs the URL with the protocol, address, and port if not using 80 for http and 443 for https.
e.g. `-s http://192.168.2.90:5000`

### id3-rate-group

Manually modify the rating and group values in bulk

`usage: id3-rate-group.py [-h] [-g] [-r] [-v VALUE] [-e EMAIL] [-o] input`

**This is a work in progress** from before I figured out how to use the MB server to pull ratings via API. 
I want to be able to assign group and ratings in bulk. This goes through all the files and allows 
me to provide a rating or group (or both) to each title with minimal typing.

I plan to use the grouping field in the future when creating daily playlists with how frequently
I'd like to hear a song (daily, weekly, monthly, quarterly, yearly, or never).

### fix-ytm-titles

Another script that's probably specific to me. Attempts to determine artist and title from the file name. Meant 
for when the input is of the form `number - artist - title.ext`, which often happens with songs pulled from
streaming sites.

`usage: fix-ytm-titles.py [-h] [-o OUTPUT] input`

Generates a batch file to run that called eyed3 to set fields and then renames the file using REN.
This has to run on Windows CMD or Powershell.

## Requirements

You may need some or all of these to run the scripts. Sorry, I don't have a requirements.txt
for you to run.

* eyeD3
* ffcuesplitter
* ffmpeg
* ffprobe
* musicbrainzngs
* mutagen
* python-ffmpeg
* python-slugify
* regex
* requests
* setuptools
* Unidecode
* urllib3 
